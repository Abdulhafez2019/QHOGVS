# -*- coding: utf-8 -*-
"""Copy of HOGv3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nnf9Hp80uwtaVf3tvB31JACxudkaUT0F
"""

from google.colab import drive
drive.mount('/content/drive')

from skimage.feature import hog
from skimage import data, exposure
from skimage.util.shape import view_as_blocks
from scipy.interpolate import BSpline
import numpy as np
from matplotlib import pyplot as plt
from skimage import io
from skimage import filters
import math
import multiprocessing as mp
import time
from itertools import product
import cv2
import csv

#images retrival

#path_vid = cv2.VideoCapture("/content/sample_video.mp4")
#path_vid = cv2.VideoCapture("/content/drive/MyDrive/yahya-research/dataset_videos/trash_2.mp4")
path_vid = cv2.VideoCapture("/content/drive/MyDrive/yahya-research/vs_demo.mp4")

fps = path_vid.get(cv2.CAP_PROP_FPS)
frame_count = int(path_vid.get(cv2.CAP_PROP_FRAME_COUNT))
duration = frame_count / fps

# start_frame = int(294 * fps) # in frames = time(seconds) * FPS
# target_frame = int(298 * fps) # in frames = time(seconds) * FPS

image_scale = 1 #6 # 1080, 1920 => 180,320

start_frame = int(0 * fps) #int(34 * fps) #int(4 * fps) #int(4 * fps)
target_frame = int(13 * fps) #int(36 * fps) #int(5 * fps) #int(36 * fps)

print("The path video has: {} FPS, {} framers, {} s, {} -> {}".format(fps,frame_count,duration,start_frame,target_frame))


frame_cnt = 0

frames_no = range(start_frame,target_frame,1)
print(frames_no)

frame_size_y = 360 #1080
frame_size_x = 480 #1920

if path_vid.isOpened():
  ret, frame = path_vid.read()
  frame_size_y = frame.shape[0]
  frame_size_x = frame.shape[1]
  path_vid.release()
path_vid = cv2.VideoCapture("/content/drive/MyDrive/yahya-research/vs_demo.mp4")

new_size_y = int(frame_size_y/image_scale)
new_size_x = int(frame_size_x/image_scale)

print(f"scale from:{frame_size_y},{frame_size_x} to {new_size_y},{new_size_x}")

imgs = np.zeros((len(frames_no),new_size_y,new_size_x))
target_image  = np.zeros((new_size_y,new_size_x))

print(f"process: {imgs.shape[0]} frames")

img_cnt = 0

while (path_vid.isOpened() and frame_cnt < frame_count):
    ret, frame = path_vid.read() # Capture frame-by-frame
    frame = cv2.resize(frame, (new_size_x , new_size_y), interpolation = cv2.INTER_AREA)
    frame = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)
    if frame_cnt in frames_no:
        imgs[img_cnt] = frame
        img_cnt = img_cnt + 1
        # fig,( ax11, ax12)  = plt.subplots(1, 2, figsize=(8, 8), sharex=True, sharey=True)
        # ax11.axis('off')
        # ax11.imshow(frame, cmap=plt.cm.gray)
        # ax11.set_title('Input image')
        # plt.show()
    if frame_cnt == target_frame:
        print("key frame")
        target_image = frame

    frame_cnt = frame_cnt +1

# When everything done, release the video capture object
path_vid.release()

fig,(ax1, ax2,ax3)  = plt.subplots(1, 3, figsize=(16, 16), sharex=True, sharey=True)
ax1.axis('off')
ax1.imshow(imgs[0], cmap=plt.cm.gray)
ax1.set_title('I0')
ax2.axis('off')
ax2.imshow(target_image, cmap=plt.cm.gray)
ax2.set_title('I*')
ax3.axis('off')
ax3.imshow(target_image-imgs[0], cmap=plt.cm.gray)
ax3.set_title('I0-I*')
plt.show()


#TODO store key frames and feature vector in folder.

# #read image
# image = io.imread('/content/img1s.PNG',as_gray=True)
# target_image = io.imread('/content/img2s.PNG',as_gray=True)


#settings
_num_bins = 10
#_cell_size= (45, 40) # pixels (y,x)
_cell_size= (60, 60)
_cells_num_y = int(target_image.shape[0]/_cell_size[0])#int(target_image.shape[0]/_cell_size[0] )
_cells_num_x = int(target_image.shape[1]/_cell_size[1]) #int(image.shape[1]/_cell_size[1] )
_depth = 2.0 # in meter
_lambda = 10 # in control law
_micro = 2 # in control law
_sigma = 1 # in qualitative vs
_rho = 4 # in qualitative vs
#sigma rho imact
# 10 0.5 (@ frame 200 start some velos)
velocities = []
Matusita_distances = []

print("image shape:{} pixels".format(target_image.shape))
print("number of bins:{} and cell size: {}x{} pixels".format(_num_bins,_cell_size[0],_cell_size[1]))

def BSplines2(t):
        if t>=-1.0 and t<0.0:
            return t+1
        elif t>=0.0 and t< 1.0:
            return 1-t
        else:
            return 0

def BSplines1(t):
        if t>=-0.5 and t<0.5:
            return 1
        else:
            return 0

def derivative_BSplines(t):
    return (BSplines1(t+0.5) - BSplines1(t-0.5))

derivative_BSplines_vec = np.vectorize(derivative_BSplines)
BSplines2_vec = np.vectorize(BSplines2)

# interaction matrix accross all pixele in the image
cells_inter_matrix = np.zeros((target_image.shape[0] , target_image.shape[1], 2 , 6))

#Point coordinates conversion from pixel coordinates $(u,v)$ to normalized coordinates $(x,y)$ in meter.
# convert x = (u-u0)/px ,y = (v - v0)/py
# https://visp-doc.inria.fr/doxygen/visp-2.9.0/classvpPixelMeterConversion.html#af85fde655f43b2213fc031361346cdae
px = 626 # pixel size
py = 630

uv_compination = product(range(0,target_image.shape[1]),range(0,target_image.shape[0]))

points = []
for i, pixel in enumerate(uv_compination):
  x = (pixel[0] -  target_image.shape[1]/2)/px
  y = (pixel[1] - target_image.shape[0]/2)/py
  points.append((x,y))

l_cells_inter_matrix = map(lambda num: (np.array([[-1/_depth, 0 ,num[0]/_depth, num[0]*num[0], -1*(1+num[0]**2), num[1] ],
                                  [0, -1/_depth, num[1]/_depth, 1+num[1]**2, -1*num[0]*num[1] , -1*num[0]]],
                                  np.float32)), points)
cells_inter_matrix = np.array(list(l_cells_inter_matrix))

cells_inter_matrix = cells_inter_matrix.reshape((_cells_num_y * _cells_num_x,  _cell_size[0] * _cell_size[1], 2 , 6))

fig,axs  = plt.subplots(2, 1,figsize=(16, 16))

for I in imgs[:]:

  setup_start_time = time.time()
  total_time = time.time()
  #cells image
  cells_img = np.zeros((_cells_num_y , _cells_num_x, _cell_size[0], _cell_size[1]))

  #pixels gradient for each cell
  cells_grad_x = np.zeros((_cells_num_y , _cells_num_x, _cell_size[0], _cell_size[1]))
  cells_grad_xx = np.zeros((_cells_num_y , _cells_num_x, _cell_size[0], _cell_size[1]))
  cells_grad_y = np.zeros((_cells_num_y , _cells_num_x, _cell_size[0], _cell_size[1]))
  cells_grad_yy = np.zeros((_cells_num_y , _cells_num_x, _cell_size[0], _cell_size[1]))
  cells_grad_xy = np.zeros((_cells_num_y , _cells_num_x, _cell_size[0], _cell_size[1]))

  I_grad_x = filters.sobel_h(I)
  I_grad_xx = filters.sobel_h(I_grad_x)
  I_grad_y = filters.sobel_v(I)
  I_grad_yy = filters.sobel_v(I_grad_y)
  I_grad_xy = filters.sobel_v(I_grad_x)


  cells_img = view_as_blocks(I, block_shape=(_cell_size[0],_cell_size[1]))
  cells_grad_x = view_as_blocks(I_grad_x, block_shape=(_cell_size[0],_cell_size[1]))
  cells_grad_xx = view_as_blocks(I_grad_xx, block_shape=(_cell_size[0],_cell_size[1]))
  cells_grad_y = view_as_blocks(I_grad_y, block_shape=(_cell_size[0],_cell_size[1]))
  cells_grad_yy = view_as_blocks(I_grad_yy, block_shape=(_cell_size[0],_cell_size[1]))
  cells_grad_xy = view_as_blocks(I_grad_xy, block_shape=(_cell_size[0],_cell_size[1]))

  cells_img = cells_img.reshape((_cells_num_y * _cells_num_x, _cell_size[0], _cell_size[1]))

  # fig,ax1  = plt.subplots(1, 1, figsize=(8, 8), sharex=True, sharey=True)
  # ax1.axis('off')
  # ax1.imshow(B[0,0], cmap=plt.cm.gray)
  # plt.show()

  cells_grad_x = (cells_grad_x.reshape((_cells_num_y * _cells_num_x, _cell_size[0] * _cell_size[1],1)) * 255) + 0.000001 # the 0.000001 is to avoid divid by zero
  cells_grad_y = (cells_grad_y.reshape((_cells_num_y * _cells_num_x, _cell_size[0] * _cell_size[1],1)) * 255) + 0.000001
  cells_grad_xx = cells_grad_xx.reshape((_cells_num_y * _cells_num_x, _cell_size[0] * _cell_size[1],1)) * 255
  cells_grad_yy = cells_grad_yy.reshape((_cells_num_y * _cells_num_x, _cell_size[0] * _cell_size[1],1)) * 255
  cells_grad_xy = cells_grad_xy.reshape((_cells_num_y * _cells_num_x, _cell_size[0] * _cell_size[1],1)) * 255

  # = 1+ (grad_y/grad_x)**2
  cells_grad_y_over_x = (cells_grad_y / cells_grad_x)
  cells_grad_one_plus_pow_y_over_x = np.power(cells_grad_y_over_x,2) + 1

  # power of pixels gradient
  cells_pow_grad_x = np.power(cells_grad_x,2)
  cells_pow_grad_y = np.power(cells_grad_y,2)

  # sqrt of pixels gradient_x + gradient_y
  cells_sqrt_pow_grad_y_plus_grad_x = np.sqrt(cells_pow_grad_x + cells_pow_grad_y)

  # interaction matrix for grad_x and grad_y
  interaction_matrix_gradient_x = cells_grad_xx * cells_inter_matrix[:, :, 0, :] + cells_grad_xy * cells_inter_matrix[:, : ,1, :]
  interaction_matrix_gradient_y = cells_grad_xy * cells_inter_matrix[:, :, 0, :] + cells_grad_yy * cells_inter_matrix[:, : ,1, :]

  derivative_pos_grady_gradx = cells_grad_x * interaction_matrix_gradient_x - cells_grad_y * interaction_matrix_gradient_x
  derivative_pos_grady_gradx = derivative_pos_grady_gradx / cells_pow_grad_x;

  # derivative of norm gradient
  derivative_norm_grad = cells_grad_x * interaction_matrix_gradient_x + cells_grad_y * interaction_matrix_gradient_y
  derivative_norm_grad = derivative_norm_grad / cells_sqrt_pow_grad_y_plus_grad_x

  derivative_pos_grady_gradx_over_scale = derivative_pos_grady_gradx / cells_grad_one_plus_pow_y_over_x

  # pixels angle(direction) for each cell
  #cells_angle = np.arctan(cells_grad_y_over_x)
  cells_angle = (np.arctan2(cells_grad_y, cells_grad_x) - np.arctan2(0.0,1.0)) * (180.0 / np.pi) + 180.0;

  # angle for each pixel in each cell substracted with bin number
  cells_BSplines_angle_minus_bin_num = np.zeros((_cells_num_y * _cells_num_x,_num_bins,_cell_size[0] * _cell_size[1],1))
  derivative_i_BSplines = np.zeros((_cells_num_y * _cells_num_x,_num_bins,_cell_size[0] * _cell_size[1],1))
  derivative_pos_BSplines = np.zeros((_cells_num_y * _cells_num_x,_num_bins,  _cell_size[0] * _cell_size[1], 6))
  derivative_pos_bin = np.zeros((_cells_num_y * _cells_num_x, _num_bins,  _cell_size[0] * _cell_size[1], 6))

  for i in range(0,_num_bins):
      cells_BSplines_angle_minus_bin_num[:,i] = cells_angle[:] - i

  cells_angle_minus_bin_num = cells_BSplines_angle_minus_bin_num

  ##### compute BSpline with vectorized matrices ######

  ones_arr = np.ones_like(cells_BSplines_angle_minus_bin_num)
  zeros_arr = np.zeros_like(cells_BSplines_angle_minus_bin_num)
  minus_ones_arr = ones_arr * -1

  # orginal_zeros = np.equal(cells_BSplines_angle_minus_bin_num,zeros_arr)

  # compare_with_minus_one_res = np.greater_equal(cells_BSplines_angle_minus_bin_num,minus_ones_arr) # zero in this matrix means either originally zero or asserted
  # cells_BSplines_angle_minus_bin_num = cells_BSplines_angle_minus_bin_num * compare_with_minus_one_res # has orginal zeros and assered zeros
  # # orginal_zeros_1 = np.equal(cells_BSplines_angle_minus_bin_num,zeros_arr) # orginal + asserted
  # # fake_zero_1 = np.logical_xor(orginal_zeros,orginal_zeros_1) # only asserted zeros

  # compare_with_one_res = np.less(cells_BSplines_angle_minus_bin_num,ones_arr)
  # cells_BSplines_angle_minus_bin_num = cells_BSplines_angle_minus_bin_num * compare_with_one_res
  # orginal_zeros_2 = np.equal(cells_BSplines_angle_minus_bin_num,zeros_arr) # orginal zeros + asserted from 1 + assterted from 2
  # fake_zero_2 = np.logical_xor(orginal_zeros,orginal_zeros_2) # asserted from 1 + assterted from 2

  # #fake_zero = np.logical_not(fake_zero_2+fake_zero_1) # mask of zeros asserted due to out of range
  # fake_zero = np.logical_not(fake_zero_2) # mask of zeros asserted due to out of range


  # compare_with_zero_res1 = np.less(cells_BSplines_angle_minus_bin_num,zeros_arr)
  # cells_BSplines_angle_minus_bin_num_cond1 = (cells_BSplines_angle_minus_bin_num + 1)  * compare_with_zero_res1

  # compare_with_zero_res2 = np.greater_equal(cells_BSplines_angle_minus_bin_num,zeros_arr)
  # cells_BSplines_angle_minus_bin_num_cond2 = (1 - cells_BSplines_angle_minus_bin_num) * compare_with_zero_res2

  # cells_BSplines_angle_minus_bin_num = cells_BSplines_angle_minus_bin_num_cond1 * fake_zero + cells_BSplines_angle_minus_bin_num_cond2 * fake_zero
  ###############

  cells_angle_minus_bin_num_min = cells_angle_minus_bin_num - 0.5
  cells_angle_minus_bin_num_plus = cells_angle_minus_bin_num + 0.5

  orginal_zeros_1 = np.equal(cells_angle_minus_bin_num_min,zeros_arr)
  orginal_zeros_2 = np.equal(cells_angle_minus_bin_num_plus,zeros_arr)

  half_arr = np.ones_like(cells_BSplines_angle_minus_bin_num) / 2
  min_half_arr = half_arr * -1

  compare_with_half_res = np.less(cells_angle_minus_bin_num_min,half_arr)
  orginal_zeros_m1 = np.equal(compare_with_half_res,zeros_arr) # asserted
  #fake_zero_1 = np.logical_xor(orginal_zeros_m1,orginal_zeros_1)
  fake_zero_1 = orginal_zeros_m1

  cells_angle_minus_bin_num_min = cells_angle_minus_bin_num_min * compare_with_half_res

  compare_with_half_res = np.greater_equal(cells_angle_minus_bin_num_min,min_half_arr)
  orginal_zeros_m2 = np.equal(compare_with_half_res,zeros_arr) # asserted
  #fake_zero_2 = np.logical_xor(orginal_zeros_m2,orginal_zeros_1)
  fake_zero_2 = orginal_zeros_m2

  fake_zero = np.logical_not(fake_zero_2+fake_zero_1)

  compare_with_half_res1 = (compare_with_half_res * minus_ones_arr) * fake_zero

  compare_with_half_res = np.less(cells_angle_minus_bin_num_plus,half_arr)
  orginal_zeros_m1 = np.equal(compare_with_half_res,zeros_arr)
  #fake_zero_1 = np.logical_xor(orginal_zeros_m1,orginal_zeros_2)
  fake_zero_1 = orginal_zeros_m1

  cells_angle_minus_bin_num_plus = cells_angle_minus_bin_num_plus * compare_with_half_res

  compare_with_half_res = np.greater_equal(cells_angle_minus_bin_num_plus,min_half_arr)
  orginal_zeros_m2 = np.equal(compare_with_half_res,zeros_arr)
  #fake_zero_2 = np.logical_xor(orginal_zeros_m2,orginal_zeros_2)
  fake_zero_2 = orginal_zeros_m2

  fake_zero = np.logical_not(fake_zero_2+fake_zero_1)

  compare_with_half_res2 = (compare_with_half_res * ones_arr) * fake_zero

  derivative_i_BSplines = compare_with_half_res1 + compare_with_half_res2

  ############# compute BSpline with vectorized function #########

  # derivative_i_BSplines = derivative_BSplines_vec(cells_BSplines_angle_minus_bin_num)
  cells_BSplines_angle_minus_bin_num = BSplines2_vec(cells_BSplines_angle_minus_bin_num)

  ######

  for i in range(0,_num_bins):
    derivative_pos_BSplines[:,i] = derivative_i_BSplines[:,i] * derivative_pos_grady_gradx_over_scale
    derivative_pos_bin[:,i] = cells_BSplines_angle_minus_bin_num[:,i] * derivative_norm_grad
    derivative_pos_bin[:,i] = derivative_pos_bin[:,i] +  cells_sqrt_pow_grad_y_plus_grad_x * derivative_pos_BSplines[:,i]


  hog_fd, hog_image = hog(I,
                      orientations=_num_bins,
                      pixels_per_cell=_cell_size ,
                      cells_per_block=(1, 1),
                      visualize=True,
                      feature_vector = False)

  target_hog_fd, target_hog_image = hog(target_image,
                      orientations=_num_bins,
                      pixels_per_cell=_cell_size ,
                      cells_per_block=(1, 1),
                      visualize=True,
                      feature_vector = False)


  hog_fd = hog_fd.reshape((hog_fd.shape[0]*hog_fd.shape[1],hog_fd.shape[4]))
  target_hog_fd = target_hog_fd.reshape((target_hog_fd.shape[0]*target_hog_fd.shape[1],target_hog_fd.shape[4]))

  target_over_current_hog_fd = 1.000001 - np.sqrt(target_hog_fd / (hog_fd + 0.000001))

  # distance between hof feature vector
  distance_fd =np.sqrt( hog_fd ) - np.sqrt(target_hog_fd)
  distance_pow_fd = np.power(distance_fd,2)

  distances = np.zeros((_cells_num_y * _cells_num_x, 1))

  print("setup time:{}",time.time()-setup_start_time)

  start_time = time.time()

  # HOG interaction matrix for each cell to form the full stack later
  L_H = np.zeros(( _cells_num_y * _cells_num_x, 6))

  for cell_num in range(0,_cells_num_y*_cells_num_x):

    dd = map(lambda bin_num:(distance_pow_fd[cell_num,bin_num]),range(0,_num_bins))
    val = np.array(list(dd))
    distances[cell_num] = val.sum()

    vals= np.zeros((_num_bins,6))

    ll = map(lambda bin_num: ( (derivative_pos_bin[cell_num,bin_num,:].sum(axis=0)/(_cell_size[0]*_cell_size[1]))
    * target_over_current_hog_fd[cell_num,bin_num]) ,range(0,_num_bins))
    vals = np.array(list(ll))

    #print(vals.sum(axis=0))
    cell_LH = _num_bins * vals.sum(axis=0)
    L_H[cell_num] = cell_LH

  ###### Qualitative
  distances_vect = (_rho / (distances+0.0001)) - (distances * _sigma)
  distances_vect = np.exp(distances_vect)
  distances_vect = distances_vect + 1.0001
  distances_vect = 1/distances_vect

  for i in range(0,distances_vect.shape[0]):
    if distances_vect[i,0] <= 0:
      distances_vect[i,0] = 0
    elif distances_vect[i,0] > _rho/(2*_sigma):
      distances_vect[i,0] = 1

  H_D = np.diag(distances_vect[:,0])

  L_H = np.matmul(H_D, L_H)

  Matusita_distances.append(distances.sum(axis=0)/(_cells_num_y * _cells_num_x))

  distances = np.matmul(H_D,distances)
  #####################

  H_H = np.matmul(np.transpose(L_H), L_H)

  print("interaction matrix calc took:{}s".format(time.time() - start_time))

  V =  np.matmul(np.linalg.pinv(H_H + _micro * np.diag(np.diag(H_H))),np.matmul(np.transpose(L_H),distances))
  print(f"distances={distances.sum(axis=0)/(_cells_num_y * _cells_num_x)}")

  V = V * -1 * _lambda
  V = V.reshape(6)
  velocities.append(V)
  print(V)
  print("total_time={}\r\n =========== ".format(time.time()-total_time))

velo = np.array(velocities)

l1 = axs[0].plot(range(0,len(frames_no)),velo[:,0],label='T_x')
l2 = axs[0].plot(range(0,len(frames_no)),velo[:,1],label='T_y')
l3 = axs[0].plot(range(0,len(frames_no)),velo[:,2],label='T_z')
l4 = axs[0].plot(range(0,len(frames_no)),velo[:,3],label='R_x')
l5 = axs[0].plot(range(0,len(frames_no)),velo[:,4],label='R_y')
l6 = axs[0].plot(range(0,len(frames_no)),velo[:,5],label='R_z')
axs[0].legend(loc='best')

axs[0].set_ylabel('Veclocities')
axs[0].set_xlabel('Frames')



axs[1].plot(range(0,len(frames_no)),Matusita_distances)
axs[1].set_xlabel('Frames')
axs[1].set_ylabel('distance')

plt.show()

np.savetxt("foo.csv", velo, delimiter=",")



plt.plot(range(0,len(frames_no)),velo[:,1],label='T_y')

plt.plot(range(0,len(frames_no)),velo[:,5],label='R_z')

plt.ylabel('Veclocities')
plt.xlabel('Frames')

plt.legend(loc='best')

plt.show()

